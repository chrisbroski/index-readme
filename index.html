<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1.2, user-scalable=no">
<title>README</title>
<style type="text/css">
html {padding: 10px 10px 200px; font-family: droid sans, sans-serif; }
body {margin: 0 auto; max-width: 580px; }
div.article > *:first-child {margin-top: 0; }
div.article p {line-height: 1.4em; font-size: 17px; }

h1 {border-bottom: 1px solid #ddd; }
pre {padding: 1em; background: #eee; overflow: auto; }
</style>

<body>
<div class="article">
<div data-src="README.md" class="mdImport"></div>
</div>

<script>
function countHash(txt) {
    if (!txt) {
        return -1;
    }
    txt = txt.slice(0, 6);
    return txt.lastIndexOf('#') + 1;
}

function replaceLink(mdLink) {
    var linkText, linkHref = '';
    linkText = mdLink.slice(1, mdLink.indexOf(']('));
    linkHref = mdLink.slice(mdLink.indexOf('](') + 2, -1);
    return '<a href="' + linkHref + '">' + linkText + '</a>'
}

function replaceBold(boldMatch) {
    return '<strong>' + boldMatch.slice(2, -2) + '</strong>';
}

function replaceItalic(italicMatch) {
    return '<em>' + italicMatch.slice(1, -1) + '</em>';
}

function replaceInline(txt, reReplace, replacer) {
    var aMatch = txt.match(reReplace), ii, len;
    if (aMatch) {
        len = aMatch.length;
        for (ii = 0; ii < len; ii = ii + 1) {
            txt = txt.replace(aMatch[ii], replacer(aMatch[ii]));
        }
    }
    return txt;
}

function convertFromMd(md) {
    var aMd,
        htmlTmp = '',
        htmlNext = '',
        countTmp = 0,
        openTag = '',
        htmlMd = [],
        ii,
        len,
        reLinks = /\[[^\]]+\]\([^\)]+\)/g;

    md = md.replace(/  \n/gi, "<br>\n"); // replace "  \n" with "<br>"
    aMd = md.split("\n");
    len = aMd.length;
    aMd.push('');

    for (ii = 0; ii < len; ii = ii + 1) {
        htmlTmp = aMd[ii];
        htmlNext = aMd[ii + 1];
        if (htmlTmp === '' || htmlTmp.slice(0, 1) === '=' || htmlTmp.slice(0, 1) === '-') {
            continue;
        }
        // BLOCK
        
        // h1
        if (htmlNext.slice(0, 1) === '=') {
            htmlTmp = '<h1>' + htmlTmp + '</h1>';
        }
        // h2
        if (htmlNext.slice(0, 1) === '-') {
            htmlTmp = '<h2>' + htmlTmp + '</h2>';
        }
        // h3 - h6
        if (htmlTmp.slice(0, 1) === '#') {
            countTmp = countHash(htmlTmp);
            htmlTmp = '<h' + countTmp + '>' + htmlTmp.slice(countTmp) + '</h' + countTmp + '>';
        }
        // pre
        if (htmlTmp.slice(0, 4) === '    ') {
            if (openTag !== 'pre') {
                openTag = 'pre';
                htmlTmp = '<pre>' + htmlTmp.slice(4);
            } else {
                htmlTmp = htmlTmp.slice(4);
            }
            if (htmlNext.slice(0, 4) !== '    ') {
                openTag = '';
                htmlTmp = htmlTmp + '</pre>' + "\n";
            }
        } else {
            // p
            if (htmlNext.slice(0, 1) === '') {
                htmlTmp = '<p>' + htmlTmp;
            }
        }

        // INLINE

        // links
        htmlTmp = replaceInline(htmlTmp, reLinks, replaceLink);

        // bold
        htmlTmp = replaceInline(htmlTmp, /\*\*[^\*]+\*\*/g, replaceBold);

        // italic
        htmlTmp = replaceInline(htmlTmp, /\*[^\*]+\*/g, replaceItalic);

        htmlMd.push(htmlTmp);
    }

    return htmlMd.join("\n");
}

function mdInclude(filePath, el) {
    var importedHTML = '',
        xhr = new XMLHttpRequest();

    // get file with ajax
    xhr.open("GET", filePath, true);
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
            if (xhr.status === 200 || xhr.status === 304) {
                el.innerHTML = convertFromMd(xhr.responseText);
            } else if (xhr.status === 404) {
                console.log('Not found: ' + xhr.responseURL);
            } else {
                console.log(xhr);
            }
        }
    }
    xhr.send(null);
}

mdInclude('README.md', document.querySelector('div.mdImport'));

</script>
